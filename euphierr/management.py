"""
MIT License

Copyright (c) 2023-present noaione

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

import re
from io import BytesIO
from math import inf as Infinity
from mimetypes import guess_type
from pathlib import Path
from typing import Dict, List

import yaml
from aiopath import AsyncPath

from euphierr.models import ArcNCielData, ArcNCielDataContent, SeriesSeason

__all__ = (
    "get_downloaded_series",
    "get_arcnciel_data",
    "save_arcnciel_data",
)
ROOT_DIR = Path(__file__).absolute().parent.parent
ARCNCIEL_PATH = ROOT_DIR / ".arcnciel-data"
ARCNCIEL_PATH.mkdir(exist_ok=True)
EPISODE_RE = re.compile(r"Episode S?(?P<season>[\d]+)?E(?P<episode>[\d]+)")


async def get_downloaded_series(series: SeriesSeason):
    series_folder = AsyncPath(series.target_dir)
    episode_mappings: Dict[str, List[int]] = {}
    async for season_dir in series_folder.iterdir():
        if (await season_dir.is_dir()) and season_dir.name.startswith("Season"):
            season_num = int(season_dir.name.split(" ", 1)[1])
            async for episode in season_dir.iterdir():
                if not await episode.is_file():
                    continue
                if (ep_match := EPISODE_RE.match(episode.name)) is None:
                    continue

                mimetype = guess_type(episode.name)[0]
                if mimetype is None:
                    continue
                if not mimetype.startswith("video"):
                    continue
                season_match = ep_match.group("season")
                if season_match is None:
                    season_match = season_num
                episode_match = int(ep_match.group("episode"))
                season_map = episode_mappings.get(str(season_match), [])
                season_map.append(episode_match)
                episode_mappings[str(season_match)] = season_map
    return episode_mappings


async def get_arcnciel_data(series: SeriesSeason):
    arcnseries = ARCNCIEL_PATH / f"{series.id}.yml"
    if not arcnseries.exists():
        return ArcNCielData(series.id, [])

    with open(arcnseries, "r") as f:
        data = yaml.safe_load(f)

    series_id = data.get("id", series.id)
    series_contents = data.get("contents")
    if not isinstance(series_contents, list):
        series_contents = []

    parsed_contents: List[ArcNCielDataContent] = []
    for content in series_contents:
        if not isinstance(content, dict):
            continue
        try:
            episode = int(content.get("episode"))  # type: ignore
            season = int(content.get("season"))  # type: ignore
            path = content.get("path")
            parsed_contents.append(ArcNCielDataContent(episode, season, path))  # type: ignore
        except (TypeError, ValueError):
            continue
    return ArcNCielData(series_id, parsed_contents)


async def save_arcnciel_data(data: ArcNCielData):
    arcnseries = AsyncPath(ARCNCIEL_PATH / f"{data.id}.yml")
    as_json_repr = {
        "id": data.id,
        "contents": [
            {
                "episode": c.episode,
                "season": c.season,
                "path": c.path,
            }
            for c in data.contents
        ],
    }
    bytes_io = BytesIO()
    yaml.safe_dump(
        as_json_repr,
        bytes_io,
        indent=2,
        allow_unicode=True,
        sort_keys=False,
        default_flow_style=False,
        width=Infinity,
    )

    bytes_io.seek(0)
    as_string = bytes_io.read().decode("utf-8")
    bytes_io.close()
    prefix_data = "### This file is automatically generated by EuphieRR, do not edit this file ###"

    async with arcnseries.open("w") as fp:
        await fp.write(prefix_data + "\n" + as_string)
